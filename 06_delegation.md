# 06. Delegation

The goal of this level is for you to claim ownership of the instance you are given.

Things that might help:

- Look into Solidity's documentation on the delegatecall low level function, how it works, how it can be used to delegate operations to on-chain libraries, and what implications it has on execution scope.
- Fallback methods
- Method ids

## Solution

What should we use to pwn the contract is pretty obvious:

```solidity
function pwn() public {
  owner = msg.sender;
}
```

Things are not such simple as the contract we are using is not `Delegate` but `Delegation`, which, in turn, provides a nice fallback function:

```solidity
fallback() external {
  (bool result,) = address(delegate).delegatecall(msg.data);
  if (result) {
    this;
  }
}
```

Via `delegatecall` on `Delegate` contract we can achieve our result by calling `pwn` function.
  
Great explaination of delegatecall [here](https://medium.com/coinmonks/delegatecall-calling-another-contract-function-in-solidity-b579f804178c)

We need to figure out what the `pwn` function address is. 

> In Ethereum function call can be expressed by bytecode as long as 4 + 32 * N bytes. And this bytecode consists of two parts.
> - **Function Selector**: This is first 4 bytes of function call’s bytecode. This is generated by hashing target function’s name plus with the type of its arguments excluding empty space. For example savaValue(uint). Currently, Ethereum uses keccak-256 hashing function to create function selector. Based on this function selector, EVM can decide which function should be called in the contract.
> - **Function Argument**: Convert each value of arguments into a hex string with the fixed length of 32bytes. If there is more than one argument, concatenate
> If the user passes this 4 + 32 * N bytes bytecode to the data field of the transaction. EVM can find which function should be executed then inject arguments to that function.

Solidity provide a useful function to calculate the function address: `abi.encodeWithSignature('pwn()') == 0xdd365b8b`

Now we just need to call the `Delegation` fallback function and `pwn`:

```javascript
await contract.owner() == player
// -> false
await contract.sendTransaction({from: player, data: '0xdd365b8b'})
await contract.owner() == player
// -> true
```

## OZ Corner

Usage of `delegatecall` is particularly risky and has been used as an attack vector on multiple historic hacks. With it, your contract is practically saying "here, -other contract- or -other library-, do whatever you want with my state". Delegates have complete access to your contract's state. The `delegatecall` function is a powerful feature, but a dangerous one, and must be used with extreme care.

Please refer to the [The Parity Wallet Hack Explained](https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7) article for an accurate explanation of how this idea was used to steal 30M USD.
